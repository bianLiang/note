
<!-- html和css，html5和css3问题总结 -->
1、什么是html5？
    html5是html新的一种标准，提出html5的主要原因是无需任何插件就可以传输所有内容，
    其中包括了动画、视频、音频等等一些新属性，丰富了页面效果。
2、html5有哪些新属性？
    a、语义化标签，如header、footer、nav、aside、article、section；
    b、增强了表单特性，更好的增加了表单的输入和验证的控制，如palcehoder、required 等；
    c、音频和视频；
    d、canvas图形；
    f、地理位置的获取；
    g、元素的拖拽；
    h、Web Worker；javascript单线程语言，解决单线程问题，创建多线程
    j、Web Storage；包含localstorage没有时间限制、sessionstorage关闭浏览器缓存清除；
    k、WebSocket

<!-- ES6问题总结 -->
<!-- javascript问题总结 -->
1、MVVM的理解
    即model数据模型 view视图 viewModel数据视图的同步对象的缩写，是一种前端开发的模式；
    为什么会出现这种开发模式呢？
    在mvvm没出现前，前端开发模式是采用mvc开发模式进行开发，即model viwe controller
    数据处理层，然后返回给视图，随之前端的发展，在前端解决的业务代码越来越复杂，
    这样就造成了以下三种问题：
    a、大量调用相同的DOM API，处理繁琐，代码冗余，代码维护难；
    b、大量的操作DOM，使页面渲染性能降低、加载变慢，影响用户体验；
    c、当model发生变化时，开发者要主动更新viwe，当用户操作导致model发生变化，开发这也要更新model里的数据，增加开发成本，浪费时间；
    当时jquery的出现很好的解决了第一个问题，但是其他两个问题依然避免不了，这时mvvm的出现给前端开发带来的福音，他很好的解决了其他两个问题，
    在mvvm框架下，model和viwe没有直接联系，他们通过viweModel建立联系，model和viweModel的交互是双向的，因此viwe的数据变化会同步到model，
    model的改变也会更新viwe上面展示。
    那么mvvm也有缺点：
    a、大的model会长期持有，占用内存；
    b、viwe的代码不易复用，因为绑定了同一个model
2、浏览器访问页面需要哪些步骤
    1、DNS解析，寻找域名对应的IP地址
    2、TCP连接，三次握手
    3、发送http请求
    4、处理http请求，返回结果
    5、渲染页面，前端处理
    6、断开http请求，四次挥手
3、DNS怎么解析IP地址
    1、先检查DNS缓存，看看之前有没有登录该网页，如果有就直接返回ip地址
    2、如果没有的话，就会想本地dns发送一个查询请求
    3、如果本地dns也没有的话，向根dns发送一个查询请求
    4、根dns告诉本地dns谁是一级dns
    5、本地在向一级dns发送一个查询请求
    6、一级dns返回一个权威dns
    7、权威dns告诉本地dns最终的ip地址
4、TCP连接和断开的三次握手和四次挥手
    三次握手
    首先客户端发送一段TCP报文，其中的标记位为SYN，表示请求建立连接，服务端接受到了TCP报文，返回一段报文
    给客户端，其中标记位置为SYN和ACK，表示接受到了客户端的报文，服务端能够正常接收到客户端的数据，同意
    创建连接；客户端接受到了服务端的报文之后，返回最后一段报文，其中的标记位为ACK，表示接收到服务端同意
    连接的信号；服务端接收到客户端的确认信息，明确了数据传输正常，完成三次握手。

    为什么要进行三次握手，1、为防止服务器开启无用的连接，增加服务器的开销。2、也防止失效的报文突然传到服务器
    因而产生错误。

    四次挥手
    客户端发送一段TCP报文，标记位为FIN，表示请求释放连接；服务端接受到了前端的报文，确认了客户端想要
    释放连接，发送一段报文给客户端，标记位为ACK，表示接受到了客户端的想要释放连接的请求；服务端做好了释放
    连接的请求，再次向客户端发出一段报文，标记位为FIN,ACK表示服务端做好了释放连接的准备了；客户端收到从服务器端发出的TCP报文，
    确认了服务器端已做好释放连接的准备，并向服务器端发送一段报文，标记位位ACK，表示接收到了服务端做好释放的准备了。
    服务端接受到了，断开连接，完成四次挥手

5、http状态码
    1xx表示请求已经发出等待处理
    2xx表示请求成功
    3xx表示资源重定向
    4xx表示请求资源不存在
    5xx表示服务器处理出错
    100，继续其请求 101切换协议，服务器更具请求切换协议
    200，请求成功
    201已创建，请求成功并创建了新的资源
    202已接受，已接受请求，但是处理未完成 
    203未授权信息，返回的mate不在原始服务器，是个副本 
    204无内容，返回无内容 
    205重置内容，返回内容用户端重置内容 
    206部分内容，处理了部分get请求
    300多种选择，请求资源可包括多个位置
    301永久移动，请求资源永久移动到新的url
    302临时移动
    303查看其他地址
    304未修改，查询的资源未修改，服务器不会返回任何资源
    305使用代理，所请求的资源必须选择代理
    307临时重定向，与302类似
    400客户端请求的语法错误，服务器无法理解
    401请求要求用户的身份认证
    403服务器理解请求客户端的请求，但是拒绝执行此请求
    404 服务器无法根据客户端的请求找到资源。
    405 客户端请求中的方法被禁止
    406 服务器无法根据客户端请求的内容特性完成请求
    500 服务器内部出错
    501 尚未实施
    502 错误网关
    503 服务不可用
    504 网关超时
    505 HTTP版本不受支持
6、post和get请求区别
    1、get请求数据放在url上，而post放在body体里面
    2、get没有post请求安全，因为数据暴漏在url上
    3、get请求对数据大小有限制，post没限制
    4、get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取变量的值。
7、XSS攻击
    XSS攻击，跨站脚本攻击，是用户在输入时过滤不足产生的漏洞攻击，攻击者可以利用网站漏洞，将恶意代码
    植入进去，当用户浏览这些带有恶意代码，恶意代码就会执行，对受害者产生攻击。

    攻击的形式主要有一下几点：
    挂马攻击、盗取cookie、dos攻击、钓鱼攻击、蠕虫攻击、劫持用户web行为、结合CSRF进行攻击
    
    XSS的类型
    反射型(也叫非持久型) 攻击者将恶意代码放在url中，用户点击连接触发执行，只执行一次。
    存储型(也叫持久型) 攻击者将恶意代码存放到服务器中，用户不用点击，只要浏览此网页就能执行。
    DOM型 当浏览器收到源代码时便把HTML文本解析成DOM对象并执行，结果弹出/xss/消息框
    
    如何防止XSS攻击
8、CSRF攻击
    
<!-- vue问题总结 -->
1、说说vue的生命周期
    生命周期有8个，实例创建前后，实例挂载前后，实例更新前后，实例销毁前后，
    实例创建有beforeCreate数据和事件还没挂在，可以处理非响应式变量
    created数据、事件、监听等生成，但是还没有挂载到dom上，常用于ajax请求，初始化数据
    实例挂载有beforeMount模板编译完成，但是dom还未挂载
    mounted dom已经挂载，可以获得dom可以使用$ref访问，常用ajax请求
    实例更新brforeUpdate响应数据更新前调用，适合数据更新前访问dom，如移除事件监听
    updated 虚拟dom重新渲染之后调用
    实例销毁beforeDestroy 实例销毁之前，销毁全局定时器，解除全局事件
    destroyed 实例销毁
2、v-show和v-if的区别
    v-if根据条件进行渲染，当条件是真时，页面进行渲染，为假时什么也不做，v-show条件不管是否
    为真，页面都进行渲染，只是通过css来控制其的显示和隐藏，当页面需要频繁切换显隐可以使用v-show，
    不频繁切换，使用v-if
3、组件之间的通信
    主要分为父子组件、隔代组件、兄弟组件
    a、props和$emita父组件通过props向子组件传递数据，子组件通过$emit向父组件传递数据，这是最常见的一种通信情况；
    b、$attrs和$listeners适用于父子、隔代组件之间的传值，$attr包含了父组件上所有没有被声明为props的属性，$listeners他是父组件监听器；
    c、$emit和$on适用父子、兄弟、隔代组件之间的传值，利用一个空的vue实例，做为中央事件总线，用它来触发事件和监听事件，项目不太大时可以使用此方法
    d、vuex，实现了一个单向数据流，在全局拥有一个state存放数据，当组件要修改数据时，需要使用moution，moution提供了订阅者模式供外部插件调用，所有的异步和批量同步操作必须在action里面进行，但是action不能修改数据，必须使用moution修改state里的数据，然后渲染到视图上面去
    f、provide/inject 适用于父子、隔代组件之间的传值在父组件定义一个provide里面写入数据，子组件使用Inject接受数据
    g、$parent / $children与 ref 适用于父子之间的传值
4、双向绑定原理

<!-- angular问题总结 -->
2、angular生命周期
    生命周期也有8个，
    ngOnChanges 当绑定的输入属性值发生变化时调用
    ngOnInit 初始化数据，
    ngDoCheck 变更检查周期内调用
    ngAfterContentInit 把内容投影到组件内调用
    ngAfterContentCheck 把内容投影到组件，变更检查之后调用
    ngAfterViweInit 初始完组件视图调用
    ngAfterViweCheck 初始化组件变更检查调用
    ngOnDestroy 销毁组件
<!-- react问题总结 -->
<!-- webpack问题总结 -->
<!-- nodejs问题总结 -->
<!-- sass、less问题总结 -->